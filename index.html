<!DOCTYPE html>
<html>
  <head>
    <title>Clustered Network</title>
    <script src="./tableau.extensions.1.latest.js"></script>
    <script src="https://d3js.org/d3.v2.min.js"></script>

    <style type="text/css">
      svg {
        border: 1px solid #ccc;
      }
      body {
        font: 10px sans-serif;
      }
      circle.node {
        fill: lightsteelblue;
        stroke: #555;
        stroke-width: 3px;
      }
      circle.leaf {
        stroke: #fff;
        stroke-width: 1.5px;
      }
      path.hull {
        fill: lightsteelblue;
        fill-opacity: 0.3;
      }
      .legend {
        position: absolute;
        left: 20px;
        top: 300px;
        padding: 20px;
        background-color: rgba(255, 255, 255, 0.8);
        border-radius: 5px;
        text-align: center;
      }

      .legend-item {
        display: flex;
        align-items: center;
        margin-bottom: 5px;
      }

      .legend-color {
        display: inline-block;
        width: 15px;
        height: 15px;
        margin-right: 5px;
      }

      .legend-label {
        font-size: 12px;
      }
      
    </style>
  </head>
  <body>
        <div class="legend"></div>
    <input type="text" id="nodeIdInput" placeholder="Enter node ID">
<button onclick="highlightNode()">Highlight Node</button>
<label for="weightSlider">Link Weight Threshold:</label>
<input type="range" id="weightSlider" min="1" max="5" value="1" step="1">
<button id="updateButton" onclick="updateLinks()">Update Links</button>
<div id="tooltip" style="position: absolute; display: none; background-color: rgba(0, 0, 0, 0.8); color: white; padding: 5px; border-radius: 5px;"></div>
<input type="range" id="zoomSlider" min="0.1" max="10" step="0.1" value="1">

    <script type="text/javascript">
       var width = 1920,     // svg width
        height = 1080,     // svg height
        dr = 4,      // default point radius
        off = 50,    // cluster hull offset
        collapse = {}, // collapsed clusters
        data, net, force, hullg, hull, linkg, link, nodeg, node;

        var json_data = {
    nodes: [],
    links: []
};

      var curve = d3.svg.line()
        .interpolate("cardinal-closed")
        .tension(.85);

      var fill = d3.scale.category20();

      tableau.extensions.initializeAsync().then(function() {
        const dashboard = tableau.extensions.dashboardContent.dashboard;

        // Add event listeners for filter changes on each worksheet
        dashboard.worksheets.forEach(function(worksheet) {
          worksheet.addEventListener(tableau.TableauEventType.FilterChanged, function(filterEvent) {
            // Reload data from Tableau and update the visualization
            loadDataFromTableau();
          });
        });

        loadDataFromTableau();
      });


        function loadDataFromTableau() {
            const worksheetNodes = tableau.extensions.dashboardContent.dashboard.worksheets[0];
            const worksheetEdges = tableau.extensions.dashboardContent.dashboard.worksheets[1];

            worksheetNodes.getUnderlyingDataAsync().then(dataTableNodes => {
                let nodes = dataTableNodes.data.map(row => {
                    return {
                        name: row[1].formattedValue,
                        group: parseInt(row[3].formattedValue, 10),
                        label: row[2].formattedValue,
                        Subtopic: row[0].formattedValue
                    };
                });

                worksheetEdges.getUnderlyingDataAsync().then(dataTableEdges => {
                    let links = dataTableEdges.data.map(row => {
                        return {
                            source: parseInt(row[1].formattedValue, 10), // Convert source to an integer
                            target: parseInt(row[0].formattedValue, 10), // Convert target to an integer
                            value: parseInt(row[2].formattedValue, 10) 
                        };
                    });

                    json_data.nodes = nodes; 
                    json_data.links = links;

                    data=json_data;
                    for (var i=0; i<data.links.length; ++i) {
                    o = data.links[i];
                    o.source = data.nodes[o.source];
                    o.target = data.nodes[o.target];
      }

                  data.nodes.forEach(node => node.degree = 0);
                  data.links.forEach(link => {
  link.source.degree += 1;
  link.target.degree += 1;
});


                    
                    init();
                });
            });
        }
      
        function displayJsonData(jsonData) {
            var jsonDataDiv = document.getElementById('jsonDataDisplay');
            jsonDataDiv.innerHTML = '<h3>JSON Data</h3><pre>' + JSON.stringify(jsonData, null, 2) + '</pre>';
        }

      function noop() { return false; }

      function nodeid(n) {
        return n.size ? "_g_"+n.group : n.name;
      }

      function linkid(l) {
        var u = nodeid(l.source),
            v = nodeid(l.target);
        return u<v ? u+"|"+v : v+"|"+u;
      }

      function getGroup(n) { return n.group; }

      // constructs the network to visualize
      function network(data, prev, index, collapse) {
        collapse = collapse || {};
        var gm = {},    // group map
            nm = {},    // node map
            lm = {},    // link map
            gn = {},    // previous group nodes
            gc = {},    // previous group centroids
            nodes = [], // output nodes
            links = []; // output links

        // process previous nodes for reuse or centroid calculation
        if (prev) {
          prev.nodes.forEach(function(n) {
            var i = index(n), o;
            if (n.size > 0) {
              gn[i] = n;
              n.size = 0;
            } else {
              o = gc[i] || (gc[i] = {x:0,y:0,count:0});
              o.x += n.x;
              o.y += n.y;
              o.count += 1;
            }
          });
        }

        // determine nodes
        for (var k=0; k<data.nodes.length; ++k) {
          var n = data.nodes[k],
              i = index(n),
              l = gm[i] || (gm[i]=gn[i]) || (gm[i]={group:i, size:0, nodes:[]});

          if (collapse[i] !== true) {
            // the node should be directly visible
            nm[n.name] = nodes.length;
            nodes.push(n);
            if (gn[i]) {
              // place new nodes at cluster location (plus jitter)
              n.x = gn[i].x + Math.random();
              n.y = gn[i].y + Math.random();
            }
            n.degree = data.nodes[k].degree;
            n.label = data.nodes[k].label;
            n.Subtopic=data.nodes[k].Subtopic;
          } else {
            // the node is part of a collapsed cluster
            if (l.size == 0) {
              // if new cluster, add to set and position at centroid of leaf nodes
              nm[i] = nodes.length;
              nodes.push(l);
              if (gc[i]) {
                l.x = gc[i].x / gc[i].count;
                l.y = gc[i].y / gc[i].count;
              }
            }
            l.nodes.push(n);
          }
          // always count group size as we also use it to tweak the force graph strengths/distances
          l.size += 1;
          n.group_data = l;
        }

        for (i in gm) { gm[i].link_count = 0; }

        // determine links
        for (k=0; k<data.links.length; ++k) {
          var e = data.links[k],
              u = index(e.source),
              v = index(e.target);
          if (u != v) {
            gm[u].link_count++;
            gm[v].link_count++;
          }
          u = !collapse[u] ? nm[e.source.name] : nm[u];
          v = !collapse[v] ? nm[e.target.name] : nm[v];
          var i = (u<v ? u+"|"+v : v+"|"+u),
              l = lm[i] || (lm[i] = {source:u, target:v, size:0});
          l.size += 1;
          l.linkValue = e.value;
        }
        for (i in lm) { links.push(lm[i]); }

        return {nodes: nodes, links: links};
      }

      function convexHulls(nodes, index, offset) {
        var hulls = {};

        // create point sets
        for (var k=0; k<nodes.length; ++k) {
          var n = nodes[k];
          if (n.size) continue;
          var i = index(n),
              l = hulls[i] || (hulls[i] = []);
          l.push([n.x-offset, n.y-offset]);
          l.push([n.x-offset, n.y+offset]);
          l.push([n.x+offset, n.y-offset]);
          l.push([n.x+offset, n.y+offset]);
        }

        // create convex hulls
        var hullset = [];
        for (i in hulls) {
          hullset.push({group: i, path: d3.geom.hull(hulls[i])});
        }

        return hullset;
      }

      function drawCluster(d) {
        return curve(d.path); // 0.8
      }

      function updateDebugArea(message) {
    var debugArea = document.getElementById("debugContent");
    debugArea.textContent += message + "\n";
}

      // --------------------------------------------------------

      var body = d3.select("body");
      var tooltip = d3.select("#tooltip");

      var vis = body.append("svg")
         .attr("width", width)
         .attr("height", height);


      hullg = vis.append("g");
      linkg = vis.append("g");
      nodeg = vis.append("g");
      
      var zoomSlider = document.getElementById("zoomSlider");
var zoom = d3.behavior.zoom()
    .scaleExtent([0.5, 10])
    .on("zoom", zoomed);

// Function to handle zoom event
function zoomed() {
  var scale = d3.event.scale;
  var translate = d3.event.translate;

  // Apply the transform to the group containing the nodes and links
  hullg.attr("transform", "translate(" + translate + ")scale(" + scale + ")");
  linkg.attr("transform", "translate(" + translate + ")scale(" + scale + ")");
  nodeg.attr("transform", "translate(" + translate + ")scale(" + scale + ")");

  // Update the zoom slider value
  zoomSlider.value = scale;
}

// Function to handle zoom slider change
function zoomChanged() {
  var scale = parseFloat(zoomSlider.value);
  var translate = zoom.translate();

  // Apply the transform to the group containing the nodes and links
  hullg.attr("transform", "translate(" + translate + ")scale(" + scale + ")");
  linkg.attr("transform", "translate(" + translate + ")scale(" + scale + ")");
  nodeg.attr("transform", "translate(" + translate + ")scale(" + scale + ")");

  // Update the zoom scale
  zoom.scale(scale);
}

// Apply the zoom behavior to the SVG element
vis.call(zoom);

// Add event listener to the zoom slider
zoomSlider.addEventListener("input", zoomChanged);
      



 
      
var linkedByIndex = {};
// Initialize the index for direct and inverse links
data.links.forEach(function(d) {
  linkedByIndex[d.source.index + "," + d.target.index] = true;
  linkedByIndex[d.target.index + "," + d.source.index] = true;
});

function highlightNodesAndLinks(d, highlight) {
  // Reset styles for all nodes and links to default
  node.style("stroke", "#555").style("stroke-width", 3);
  link.style("stroke", "#333").style("stroke-opacity", 0.5);

  if (highlight) {
    // Highlight directly connected nodes
    node.each(function(o) {
      var thisNode = d3.select(this);
      var connected = isConnected(d, o);
      thisNode.style("stroke", connected ? "red" : "#555")
              .style("stroke-width", connected ? 4 : 3);
    });

    // Highlight directly connected links
    link.style("stroke", function(o) {
      return o.source === d || o.target === d ? "red" : "#333";
    }).style("stroke-opacity", function(o) {
      return o.source === d || o.target === d ? 1 : 0.5;
    });
  } else {
    // Reset styles to original state
    node.style("stroke", "#555").style("stroke-width", 3);
    link.style("stroke", "#333").style("stroke-opacity", 0.5);
  }
}

// Utilize the existing isConnected function
function isConnected(a, b) {
  return linkedByIndex[a.index + "," + b.index] || a.index === b.index;
}

      
function highlightNode() {
  // Log the selector to ensure it's what you expect
  var nodeId = document.getElementById("nodeIdInput").value.trim();
  var selector = "#node" + nodeId;
  console.log("Selector:", selector); // Check this in your browser's console

  // Attempt to select and highlight the node
  var node = d3.select(selector);
  console.log("Node selected:", node.node()); // This should log the SVG circle element if found

  // If the node is found, highlight it
  if (!node.empty()) {
    node.style("fill", "orange");
  } else {
    console.log("No node found with the ID:", selector);
  }
}

           function updateLinks() {
    var threshold = document.getElementById("weightSlider").value;
    
    link.style("opacity", function(d) {
    return d.linkValue >= threshold ? d.linkValue : 0;
  });
}


    
      function init() {
        if (force) force.stop();

        net = network(data, net, getGroup, collapse);

    // Create legend
// Create legend
        // Create groupColors object
        var groupColors = {};
        data.nodes.forEach(function(d) {
          if (d.Subtopic) {
            groupColors[d.Subtopic] = fill(d.group);
          }
        });

        // Create legend
        var legend = d3.select(".legend").html(""); // Clear previous legend

        var legendItems = legend.selectAll(".legend-item")
            .data(Object.entries(groupColors))
            .enter().append("div")
            .attr("class", "legend-item");

        legendItems.append("span")
            .attr("class", "legend-color")
            .style("background-color", function(d) { return d[1]; });

        legendItems.append("span")
            .attr("class", "legend-label")
            .text(function(d) { return d[0]; });

        force = d3.layout.force()
            .nodes(net.nodes)
            .links(net.links)
            .size([width, height])
            .linkDistance(function(l, i) {
  var n1 = l.source, n2 = l.target;
  // Check if nodes belong to different groups
  if (n1.group !== n2.group) {
    // Return a constant distance for links between different groups
    return 500; // You can adjust this value as needed
  } else {
    // Original distance calculation for nodes within the same group
    return 30 +
      Math.min(20 * Math.min((n1.size || (n1.group != n2.group ? n1.group_data.size : 0)),
                             (n2.size || (n1.group != n2.group ? n2.group_data.size : 0))),
               -30 +
               30 * Math.min((n1.link_count || (n1.group != n2.group ? n1.group_data.link_count : 0)),
                             (n2.link_count || (n1.group != n2.group ? n2.group_data.link_count : 0))),
               100);
  }
})

          .linkStrength(function(l, i) {
          return 1;
          })
          .gravity(0.1)   // gravity+charge tweaked to ensure good 'grouped' view (e.g. green group not smack between blue&orange, ...
          .charge(-1500)    // ... charge is important to turn single-linked groups to the outside
          .friction(0.5) 
          .alpha(0.1) // Start with a lower alpha
          // Adjust the alpha decay rate  // friction adjusted to get dampened display: less bouncy bouncy ball [Swedish Chef, anyone?]
            .start();

        hullg.selectAll("path.hull").remove();
        hull = hullg.selectAll("path.hull")
            .data(convexHulls(net.nodes, getGroup, off))
          .enter().append("path")
            .attr("class", "hull")
            .attr("d", drawCluster)
            .style("fill", function(d) { return fill(d.group); })
            .on("click", function(d) {
      console.log("hull click", d, arguments, this, collapse[d.group]);
            collapse[d.group] = true; init();
          });

        link = linkg.selectAll("line.link").data(net.links, linkid);
        link.exit().remove();
        link.enter().append("line")
            .attr("class", "link")
            .attr("x1", function(d) { return d.source.x; })
            .attr("y1", function(d) { return d.source.y; })
            .attr("x2", function(d) { return d.target.x; })
            .attr("y2", function(d) { return d.target.y; })
            .style("stroke-width", function(d) {
    var sourceGroupCollapsed = collapse[d.source.group];
    var targetGroupCollapsed = collapse[d.target.group];
    
    return (sourceGroupCollapsed && targetGroupCollapsed) ? d.size : d.linkValue; 
  }) 
            .style("stroke", "#333")  // Default stroke color
    .style("stroke-opacity", 0.6);

        node = nodeg.selectAll("circle.node").data(net.nodes, nodeid);
        node.exit().remove();
        node.enter().append("circle")
            // if (d.size) -- d.size > 0 when d is a group node.
            .attr("class", function(d) { return "node" + (d.size?"":" leaf"); })
        .attr("id", function(d) { return"node" +d.name; })
                     .attr("r", function(d) {
        // Check if d.degree is present
        if (d.degree !== undefined) {
            // Directly use d.degree or scale it as needed
            return d.degree; // You may apply scaling here if needed
        } else {
            // Fallback to using d.size or a default radius
            return d.size ? d.size + dr : dr + 1;
        }
    })
            .attr("cx", function(d) { return d.x; })
            .attr("cy", function(d) { return d.y; })
            .each(function(d) { console.log(this.id); })
            .style("fill", function(d) { return fill(d.group); })
            .on("mouseover", function(d) {
        var sourceGroupCollapsed = collapse[d.group];
        
        if (!sourceGroupCollapsed) {
            tooltip.style("display", "block")
                   .html(d.label)
                   .style("left", (d3.event.pageX + 10) + "px")
                   .style("top", (d3.event.pageY - 10) + "px");
        }
        
        link.style('stroke', function(l) {
            if (d === l.source || d === l.target)
                return 'red';
            else
                return 'grey';
        });
    })
    .on("mouseout", function(d) {
        var sourceGroupCollapsed = collapse[d.group];
        
        if (!sourceGroupCollapsed) {
            tooltip.style("display", "none");
        }
        
        link.style('stroke', 'grey');
        console.log("mouseout:", d.name);
    })
            .on("click", function(d) {
                var sourceGroupCollapsed = collapse[d.group];
        
        if (!sourceGroupCollapsed) {
            window.open(d.label, "_blank");
        }
      console.log("node click", d, arguments, this, collapse[d.group]);
              collapse[d.group] = !collapse[d.group];
          init();
            });
        


        node.call(force.drag);

        force.on("tick", function() {
          if (!hull.empty()) {
            hull.data(convexHulls(net.nodes, getGroup, off))
                .attr("d", drawCluster);
          }

          link.attr("x1", function(d) { return d.source.x; })
              .attr("y1", function(d) { return d.source.y; })
              .attr("x2", function(d) { return d.target.x; })
              .attr("y2", function(d) { return d.target.y; });

          node.attr("cx", function(d) { return d.x; })
              .attr("cy", function(d) { return d.y; });
        });
       
      }

    </script>
  </body>
</html>
